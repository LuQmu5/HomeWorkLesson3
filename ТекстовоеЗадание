Фабрика - предоставляет услуги настройки и выдачи каких-либо запрашиваемых объектов
для их дальнейшего инстанциирования с полученными настройками в подклассах, которые запрашивали эти объекты
Например: я делаю игру по типу тавер дифенс, где мне нужно задефать 10 волн крипов, каждую волну крипы разные (от слабых к сильным). Их будет спавнить спавнер, а запрашивать рандомного крипа
он будет от фабрики, которой в метод получения крипа передается номер текущей волны, на основе которой фабрика создает и настраивает подходящего по силе крипа 
и возвращает его из этого же метода.
Я делаю рогалик с сундуками, где из сундуков должны выпадать рандомные шмотки, которые соответствуют классу выбранного мной персонажа. При взаимодействии с сундуком из фабрики лута
будет запрашиваться этот самый рандомный лут за счет метода, в который я передам класс моего персонажа, а фабрика на основе класса сгенерирует настроит и вернет какой-нибудь рандомный
лутецкий.

Визитер - выполняет какое-либо действие, работя с каким-либо наследником базового класса в зависимости от которого действие будет иметь разные эффекты
Например, у меня есть шутер, где есть различные предметы, по которым может попасть выстрел из оружия, я добавляю на них условно интерфейс IWeaponVisitor,
в котором я делаю метод Visit() которому в качестве параметра за счет перегрузок прописываю все имеющиеся типы оружия в игре (и если нужно еще и другие параметры,
например для оружия ближнего боя я, наверное, ничего не передавал бы, т.к оно бьет за счет оверлапа, а для оружий дальнего боя какую-нибудь рэйкаст инфу)
так вот, а уже в наследниках интерфейса IWeaponVisitor (например в условной коробке деревяной) я реализую интерфейс и прописываю, что будет происходить для каждого
типа оружия при попадании выстрела по этому объекту, например при попадании любого оружия дальнего боя по коробке можно, помимо разрушения, прописать спавн партиклов импакта от выстрела
Сам же метод Visit у этих объектов будет вызываться при попадании пули по ним через метод Accept()
Еще 1 пример: 
Я делаю зельдоподобную (ГЕНЩИТ ВСЕ УКРАЛ!) игру, где есть физическохимическобиологическое взаимодействие с различными стихиями и создаю интерфейс
IElementalVisitor, в котором делаю перегрузку Visit для различных стихийных типов
А затем во всех сущностях, на которые эти стихии как-либо могут влиять реализовываю этот интерфейс, прописывая реакцию на каждую из стихий через тот же метод Accept()
Например, у меня есть сущность "вода", у которой если вызвать Visit для стихии ветра, то вода замерзнет, а если огонь, то испарится

Декоратор - позволяет навешивать на сущность новый функционал за счет использования разных наследников класса для реализации какого-либо функционала этой сущности

Например: мы имеем класс (хочу) питсы, которая чета там в себе базовое реализует, например, стоимость, вес и тип таво, затем делаем декоратор для этой питсы,
который наследует базовый класс, а также принимает в  свой конструктор тоже базовый класс питцы, а затем от этого декоратора наследуем конкретные декораторы, например
Пицца вегетерианская, которая будет убирать из питцы все ингридиенты с типом мясо, либо таким же образом питцу без овощей, питцу-квадрат, питцу из половинок 
(еще 1 пиццу в своем конструкторе принимает и объединяет) и т.д.

Либо же имеем интерфейс IDamagerStat со свойстами MinValue, MaxValue и методом GetCalculatedDamage, возвращающим число
Делаем базовый класс SimpleDamagerStat и реализуем в нем интерфейс, где просто рандомим в методе GetCalculatedDamage наносимый урон от мин до макс
А затем делаем декораторы, например: CriticalDamagerStat, который принимает в конструкторе IDamagerStat, дополняя его метод обычного расчета наносимого урона параметром 
DamageMultiplier, на который этот урон помножится и затем уже вернется
ComboDamagerStat, который по аналогии с предыдущим примером дополняет расчет наносимого урона в зависимости от текущего числа комбо 
(например помонжает 1.(серия_комбо)f * рассчитанный урон) 

